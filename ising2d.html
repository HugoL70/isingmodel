<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Ising Model</title>
<style>
  body { background: #000; color: #fff; font-family: sans-serif; text-align: center; }
  canvas { border: 1px solid #333; display: block; margin: 0 auto; }
  #controls { margin-top: 10px; }
  button { font-size: 16px; margin-left: 10px; }
  input[type="text"] { width: 80px; font-size: 16px; }
  h2 { margin-bottom: 5px; }
</style>
</head>
<body>

<h2 id="topologyHeading">Current Topology: Klein Bottle</h2>

<canvas id="gameCanvas" width="1200" height="750"></canvas>

<div id="controls">
  beta:
  <input
    type="range"
    id="betaSlider"
    min="0.01"
    max="3.0"
    step="0.0001"
    value="0.1"
    style="width: 600px;"
  >
  <input type="text" id="betaInput" value="0.1000">
  <button id="topologyBtn">Switch to Torus</button>
</div>

<script>
const GRID_W = 400;
const GRID_H = 250;
const CELL_SIZE = 3;
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// ---- Beta handling ----
let beta = parseFloat(document.getElementById('betaSlider').value);
const betaInput = document.getElementById('betaInput');

betaInput.value = beta.toFixed(4);

// Slider → input box
document.getElementById('betaSlider').addEventListener('input', (e) => {
  beta = parseFloat(e.target.value);
  betaInput.value = beta.toFixed(4);
});

// Input box → slider
betaInput.addEventListener('change', (e) => {
  let val = parseFloat(e.target.value);
  if (isNaN(val)) val = beta;
  val = Math.max(0.01, Math.min(3.0, val)); // enforce range
  beta = val;
  betaInput.value = beta.toFixed(4);
  document.getElementById('betaSlider').value = beta;
});

const colours = [[250,80,50],[0,0,230]];

// Initialize grid randomly
let grid = [];
for (let y=0; y<GRID_H; y++) {
  let row = [];
  for (let x=0; x<GRID_W; x++) {
    row.push(Math.random() < 0.5 ? -1 : 1);
  }
  grid.push(row);
}

// Mouse painting
let leftDown = false;
let rightDown = false;

canvas.addEventListener('mousedown', (e) => {
  if (e.button === 0) leftDown = true;
  if (e.button === 2) rightDown = true;
});
canvas.addEventListener('mouseup', (e) => {
  if (e.button === 0) leftDown = false;
  if (e.button === 2) rightDown = false;
});
canvas.addEventListener('contextmenu', (e) => e.preventDefault());

function paintBlock(gx, gy, value) {
  for (let dx=0; dx<4; dx++) {
    for (let dy=0; dy<4; dy++) {
      let x = (gx + dx + GRID_W) % GRID_W;
      let y = (gy + dy + GRID_H) % GRID_H;
      grid[y][x] = value;
    }
  }
}

// ---- Topology toggle ----
let isKlein = true;
const topologyBtn = document.getElementById('topologyBtn');
const topologyHeading = document.getElementById('topologyHeading');

topologyBtn.addEventListener('click', () => {
  isKlein = !isKlein;
  topologyBtn.textContent = isKlein ? 'Switch to Torus' : 'Switch to Klein';
  topologyHeading.textContent = isKlein ? 'Current Topology: Klein Bottle' : 'Current Topology: Torus';
});

// Neighbor function
function getNeighbor(y, x) {
  const xx = (x + GRID_W) % GRID_W;

  if (isKlein) {
    // Klein bottle: vertical reflection, horizontal normal
    if (y < 0) return grid[GRID_H - 1][GRID_W - 1 - xx];
    if (y >= GRID_H) return grid[0][GRID_W - 1 - xx];
    return grid[y][xx];
  } else {
    // Torus: full periodic
    const yy = (y + GRID_H) % GRID_H;
    return grid[yy][xx];
  }
}

// ---- Ising update ----
function update() {
  const J = 1;
  const updates = Math.floor((GRID_W*GRID_H) / 5);

  for (let n=0; n<updates; n++) {
    const x = Math.floor(Math.random()*GRID_W);
    const y = Math.floor(Math.random()*GRID_H);

    const energy = -J * grid[y][x] * (
      getNeighbor(y-1, x) +
      getNeighbor(y+1, x) +
      grid[y][(x-1+GRID_W)%GRID_W] +
      grid[y][(x+1)%GRID_W]
    );

    const p = 1/(1 + Math.exp(2*beta*energy));
    if (Math.random() > p) {
      grid[y][x] *= -1;
    }
  }
}

// ---- Drawing ----
function drawGrid() {
  const imageData = ctx.createImageData(canvas.width, canvas.height);
  const data = imageData.data;

  for (let y=0; y<GRID_H; y++) {
    for (let x=0; x<GRID_W; x++) {
      const color = colours[(grid[y][x]+1)/2];

      for (let dy=0; dy<CELL_SIZE; dy++) {
        for (let dx=0; dx<CELL_SIZE; dx++) {
          const px = x*CELL_SIZE + dx;
          const py = y*CELL_SIZE + dy;
          const idx = 4*(py*canvas.width + px);

          data[idx]   = color[0];
          data[idx+1] = color[1];
          data[idx+2] = color[2];
          data[idx+3] = 255;
        }
      }
    }
  }
  ctx.putImageData(imageData, 0, 0);
}

// ---- Painting ----
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  if (my >= GRID_H*CELL_SIZE) return;

  const gx = Math.floor(mx / CELL_SIZE);
  const gy = Math.floor(my / CELL_SIZE);

  if (leftDown) paintBlock(gx, gy, -1);
  if (rightDown) paintBlock(gx, gy, 1);
});

// ---- Main loop ----
function loop() {
  update();
  drawGrid();
  requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>
