<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Ising Model Game</title>
<style>
  body { background: #000; color: #fff; font-family: sans-serif; text-align: center; }
  canvas { border: 1px solid #333; display: block; margin: 0 auto; }
  #sliderContainer { margin-top: 10px; }
</style>
</head>
<body>

<canvas id="gameCanvas" width="1200" height="750"></canvas>
<div id="sliderContainer">
  beta: <input type="range" id="betaSlider" min="0.01" max="5.0" step="0.01" value="0.1">
  <span id="betaValue">0.10</span>
</div>

<script>
const GRID_W = 400;
const GRID_H = 250;
const CELL_SIZE = 3;
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let beta = parseFloat(document.getElementById('betaSlider').value);
document.getElementById('betaValue').textContent = beta.toFixed(2);

document.getElementById('betaSlider').addEventListener('input', (e) => {
  beta = parseFloat(e.target.value);
  document.getElementById('betaValue').textContent = beta.toFixed(2);
});

const colours = [[250,80,50],[0,0,230]];

let grid = [];
for (let y=0; y<GRID_H; y++) {
  let row = [];
  for (let x=0; x<GRID_W; x++) {
    row.push(Math.random() < 0.5 ? -1 : 1);
  }
  grid.push(row);
}

let leftDown = false;
let rightDown = false;

canvas.addEventListener('mousedown', (e) => {
  if (e.button === 0) leftDown = true;
  if (e.button === 2) rightDown = true;
});
canvas.addEventListener('mouseup', (e) => {
  if (e.button === 0) leftDown = false;
  if (e.button === 2) rightDown = false;
});
canvas.addEventListener('contextmenu', (e) => e.preventDefault());

function paintBlock(gx, gy, value) {
  for (let dx=0; dx<4; dx++) {
    for (let dy=0; dy<4; dy++) {
      let x = (gx + dx + GRID_W) % GRID_W;
      let y = (gy + dy + GRID_H) % GRID_H;
      grid[y][x] = value;
    }
  }
}

function update() {
  const J = 1;
  const upnum = Math.floor((GRID_W*GRID_H)/5);

  for (let n=0; n<upnum; n++) {
    const x = Math.floor(Math.random()*GRID_W);
    const y = Math.floor(Math.random()*GRID_H);

    /*const energy = -J * grid[y][x] * (
      grid[(y-1+GRID_H)%GRID_H][x] +
      grid[(y+1)%GRID_H][x] +
      grid[y][(x-1+GRID_W)%GRID_W] +
      grid[y][(x+1)%GRID_W]
    );*/

    if (y == 0) {
      const energy = -J * grid[y][x] * (
      grid[(y-1+GRID_H)%GRID_H][(-x)%GRID_W] +
      grid[(y+1)%GRID_H][x] +
      grid[y][(x-1+GRID_W)%GRID_W] +
      grid[y][(x+1)%GRID_W]);
    }
    if (y == GRID_H-1) {
      const energy = -J * grid[y][x] * (
      grid[(y-1+GRID_H)%GRID_H][(-x)%GRID_W] +
      grid[(y+1)%GRID_H][(-x)%GRID_W] +
      grid[y][(x-1+GRID_W)%GRID_W] +
      grid[y][(x+1)%GRID_W]);
    }
    else {
      const energy = -J * grid[y][x] * (
      grid[(y-1+GRID_H)%GRID_H][x] +
      grid[(y+1)%GRID_H][x] +
      grid[y][(x-1+GRID_W)%GRID_W] +
      grid[y][(x+1)%GRID_W]);
    }

    const p = 1/(1 + Math.exp(2*beta*energy));
    if (Math.random() > p) {
      grid[y][x] *= -1;
    }
  }
}

function drawGrid() {
  const imageData = ctx.createImageData(canvas.width, canvas.height);
  const data = imageData.data;
  for (let y=0; y<GRID_H; y++) {
    for (let x=0; x<GRID_W; x++) {
      const color = colours[(grid[y][x]+1)/2];
      for (let dy=0; dy<CELL_SIZE; dy++) {
        for (let dx=0; dx<CELL_SIZE; dx++) {
          const px = x*CELL_SIZE + dx;
          const py = y*CELL_SIZE + dy;
          const idx = 4*(py*canvas.width + px);
          data[idx] = color[0];
          data[idx+1] = color[1];
          data[idx+2] = color[2];
          data[idx+3] = 255;
        }
      }
    }
  }
  ctx.putImageData(imageData, 0, 0);
}

canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  if (my >= GRID_H*CELL_SIZE) return;
  const gx = Math.floor(mx / CELL_SIZE);
  const gy = Math.floor(my / CELL_SIZE);
  if (leftDown) paintBlock(gx, gy, -1);
  if (rightDown) paintBlock(gx, gy, 1);
});

function loop() {
  update();
  drawGrid();
  requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>
